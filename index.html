  <!-- Welcome Popup -->
  <div id="welcome-popup" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:9999;background:rgba(30,40,60,0.18);display:flex;align-items:center;justify-content:center;">
    <div style="background:rgba(255,255,255,0.32);max-width:600px;width:99vw;padding:24px 32px 22px 32px;border-radius:16px;box-shadow:0 8px 32px rgba(30,40,60,0.18);font-family:sans-serif;color:#263238;position:relative;font-size:0.92rem;backdrop-filter:blur(8px) saturate(180%);overflow-y:auto;max-height:78vh;">
      <button id="welcome-close" aria-label="Close welcome popup" style="position:absolute;top:12px;right:14px;background:none;border:none;font-size:1.5rem;cursor:pointer;color:#888;">&times;</button>
      <h2 style="margin-top:0;font-size:0.98rem;font-weight:700;letter-spacing:0.01em;">Welcome to MeinSalzburg!</h2>
      <img src="logo/Salzburg.jpg" alt="Salzburg" style="display:block;margin:8px 0 12px 0;width:100%;border-radius:8px;box-shadow:0 2px 12px rgba(30,40,60,0.10);object-fit:cover;" />
      <div style="font-size:0.98em;margin-bottom:8px;">This interactive map is your gateway to exploring and analyzing public services and amenities throughout the city of Salzburg.</div>
      <div style="margin-bottom:8px;font-size:1em;"><strong>What you can do here:</strong></div>
      <ul style="margin-top:0;margin-bottom:8px;padding-left:18px;font-size:0.96em;">
        <li><strong>Explore:</strong> Click on any point of interest – schools, hospitals, parks, parking lots, libraries, tourist attraction and more – to see its details.</li>
        <li><strong>Analyze:</strong> Use our proximity tools to find all amenities within your desired walking or driving distance from any location. Perfect for finding neighborhoods with specific services.</li>
        <li><strong>Plan:</strong> Looking for an apartment? Need the nearest grocery store? Planning a day out? This tool helps you understand what's around you and make informed decisions.</li>
      </ul>
      <div style="margin-bottom:8px;font-size:1em;"><strong>How to use it:</strong></div>
      <ul style="margin-top:0;margin-bottom:8px;padding-left:18px;font-size:0.96em;">
        <li>Search for an address or simply pan the map.</li>
        <li>Select an amenity type (e.g., "Schools") from the menu.</li>
        <li>Use the "Draw Area" or "Nearest Search" tool to define your distance (e.g., "500m walk").</li>
        <li>View the results and interact with the highlighted locations!</li>
      </ul>
      <div style="margin-top:8px;font-size:0.93em;color:#444;">This application is built on open data to support residents, visitors, researchers, and urban planners in experiencing Salzburg more connectedly.</div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;">
        <button id="welcome-skip" style="background:#f1f3f4;border:1px solid rgba(0,0,0,0.06);padding:8px 12px;border-radius:8px;cursor:pointer;font-size:0.92rem;color:#222">Skip</button>
        <button id="welcome-no-show" style="background:#1978c8;color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-size:0.92rem">Don't show again</button>
      </div>
    </div>
  </div>
  <script>
    // Welcome popup logic
    window.addEventListener('DOMContentLoaded', function() {
      var popup = document.getElementById('welcome-popup');
      var closeBtn = document.getElementById('welcome-close');
      var skipBtn = document.getElementById('welcome-skip');
      var noShowBtn = document.getElementById('welcome-no-show');

      // If user previously chose 'don't show again', hide immediately
      try {
        if (localStorage && localStorage.getItem && localStorage.getItem('welcome_dont_show') === '1') {
          if (popup) popup.style.display = 'none';
          return;
        }
      } catch (e) {
        // ignore localStorage errors
      }

      if (popup) {
        if (closeBtn) {
          closeBtn.addEventListener('click', function() { popup.style.display = 'none'; });
        }
        if (skipBtn) {
          skipBtn.addEventListener('click', function() { popup.style.display = 'none'; });
        }
        if (noShowBtn) {
          noShowBtn.addEventListener('click', function() {
            try { localStorage.setItem('welcome_dont_show', '1'); } catch (e) {}
            popup.style.display = 'none';
          });
        }
      }
    });
  </script>
<html>
<head>
  <meta charset="utf-8" />
  <title>Choropleth with MapLibre GL JS</title>
  <link
    href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="style.css"  />
  <style>
    body { margin: 0; padding: 0; }
    #map { width: 100%; height: 100vh; }
    .popup-table tr:nth-child(even) { background: #fce0b0; }
    /* Search box styles: positioned below top-left control to avoid overlap */
    #search-container {
      position: absolute;
      left: 80px;
      top: 12px;
      z-index: 3;
      width: 300px;
      font-family: sans-serif;
    }
    #search-input {
      width: 100%;
      padding: px 10px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      outline: none;
      font-size: 14px;
      height: 35px;
    }
    #search-results {
      margin-top: 6px;
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      max-height: 220px;
      overflow: auto;
      /*border: 1px solid rgba(0,0,0,0.06);*/
    }
    .search-item {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 13px;
      color: #222;
    }
    .search-item:hover { background: #f1f1f1 }
    /* Data sources logos inside side panel */
    #layer-panel .data-logos { display:flex; gap:8px; align-items:center; margin-top:6px; }
    #layer-panel .data-logos img { height:34px; width:auto; display:block; border-radius:4px; background:#fff; padding:4px; box-shadow:0 1px 2px rgba(0,0,0,0.08); }
    /* Top-left map control styling */
  .map-control-container{background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 6px 20px rgba(14,30,37,0.12);display:flex;flex-direction:column;gap:8px;position:relative;z-index:9}
    /* base button style */
    .map-control-container .ctrl-btn{background:#fff;border:1px solid rgba(16,24,32,0.08);padding:8px;border-radius:8px;cursor:pointer;font-size:14px;display:inline-flex;align-items:center;justify-content:center;min-width:40px;min-height:40px;box-shadow:0 1px 2px rgba(0,0,0,0.04);transition:all 180ms ease}
    .map-control-container .ctrl-btn:focus{outline:none;box-shadow:0 0 0 3px rgba(25,120,200,0.14)}
    .map-control-container .ctrl-btn:hover{background:#f4f8fb}
    /* icons inside the control buttons */
  .map-control-container .ctrl-btn svg { width: 18px; height: 18px; display: block; margin: 0 auto; fill: #263238; transition:fill 160ms ease }
  .map-control-container .ctrl-btn:hover svg { fill: #1978c8 }
  /* visually hidden text for screen readers */
  .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap;border:0;padding:0;margin:-1px}
  /* export menu */
  .export-menu{display:none;position:absolute;left:0;top:calc(100% + 8px);background:#fff;border:1px solid #eee;border-radius:8px;padding:6px;box-shadow:0 10px 30px rgba(14,30,37,0.12);min-width:150px;z-index:10}
  .export-menu.show{display:block}
  .export-menu button{display:flex;gap:8px;align-items:center;width:100%;text-align:left;padding:8px;border-radius:6px;border:none;background:transparent;cursor:pointer;font-size:14px}
  .export-menu button:hover{background:#f6f9fc}
    /* hide the panel buttons (we'll add controls on the map) */
    #layer-panel .panel-control-hidden{display:none}
    /* Legend */
    .map-legend{position:absolute; left: 12px; bottom: 12px; z-index:6; background:#fff; padding:10px; border-radius:8px; box-shadow:0 6px 20px rgba(14,30,37,0.12); font-family:sans-serif; font-size:13px; color:#222; min-width:170px}
    .map-legend h4{margin:0 0 8px 0; font-size:13px}
    .legend-item{display:flex; align-items:center; gap:8px; margin:6px 0}
    .legend-swatch{width:18px; height:12px; border-radius:3px; flex:0 0 18px; box-shadow:inset 0 0 0 1px rgba(0,0,0,0.06)}
    .legend-label{flex:1}
    /* Draggable / minimizable panel styles */
    .draggable-panel{position:absolute; background:#fff; border-radius:8px; box-shadow:0 6px 20px rgba(14,30,37,0.12); z-index:11; min-width:200px; font-family:sans-serif; transition:width 180ms ease, height 180ms ease, top 180ms ease, right 180ms ease}
    .draggable-panel .panel-header{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-top-left-radius:8px; border-top-right-radius:8px; background:linear-gradient(0deg, rgba(0,0,0,0.02), rgba(0,0,0,0.00));}
    .draggable-panel .panel-header strong{font-size:14px}
    .draggable-panel .panel-controls{display:flex; gap:6px; align-items:center}
    .draggable-panel .minimize-btn{background:#fff;border:1px solid rgba(0,0,0,0.08);padding:4px 8px;border-radius:6px;cursor:pointer;font-size:13px}
    .draggable-panel .minimize-btn:focus{outline:none;box-shadow:0 0 0 3px rgba(25,120,200,0.12)}
    .draggable-panel .panel-body{padding:10px; max-height:60vh; overflow:auto}
    .draggable-panel.collapsed{width:140px}
    .draggable-panel.collapsed .panel-body{display:none}

    /* Small icon used when collapsed */
    .draggable-panel .panel-icon{display:none}
    .draggable-panel.collapsed{ width:44px; height:44px; padding:0; overflow:hidden }
    .draggable-panel.collapsed .panel-body{display:none}
    .draggable-panel.collapsed strong{display:none}
    .draggable-panel.collapsed .minimize-btn{display:none}
    .draggable-panel.collapsed .panel-icon{display:flex; align-items:center; justify-content:center; width:100%; height:100%}

    /* When panels are minimized, position them in the top-right corner stacked as icons */
    #layer-panel.collapsed{ right:2%; top:3%; bottom:auto; width:44px; height:44px }
    #map-legend.collapsed{ right:2%; top:calc(3% + 52px); bottom:auto; width:44px; height:44px }

    /* Ensure expanded panels do not overlap: place legend below the layers panel */
    #layer-panel{ right:2%; top:3%; width:26%; max-width:420px }
    #map-legend{ right:2%; top:calc(3% + 36vh); width:18%; max-width:300px; min-width:160px }
    .draggable-panel.dragging{opacity:0.95}

    /* Layer panel default placement and sizing (use percentages for responsiveness) */
    #layer-panel{right:2%; top:3%; width:26%; max-width:420px; z-index:12}

    /* Legend placement (bottom-right) using percentages; smaller width */
    .map-legend{right:2%; bottom:3%; width:18%; max-width:300px; min-width:160px; z-index:10}

    /* Drag handle removed - panels are fixed to the right; only minimize is available */
    .drag-handle{display:none}
</style>

</head>
<body>
  <div id="map"></div>
  <div id="search-container">
    <input id="search-input" type="search" placeholder="Search place or address..." autocomplete="off">
    <div id="search-results"></div>
  </div>
    <div id="proximity-btn-container" style="position:absolute; left:392px; top:12px; z-index:3;">
      <button id="proximity-open" style="padding:8px 10px; border-radius:4px; border:1px solid rgba(0,0,0,0.12); background:#fff; cursor:pointer; box-shadow:0 1px 3px rgba(0,0,0,0.08);">Proximity Analysis</button>
    </div>

  <!-- Legend (draggable + minimizable) -->
  <div class="draggable-panel map-legend" id="map-legend" role="dialog" aria-label="Map legend">
    <div class="panel-header">
      <strong>Map legend</strong>
      <div class="panel-controls">
        <span class="panel-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" xmlns="http://www.w3.org/2000/svg"><path d="M3 13h18v-2H3v2zm0-6h18V5H3v2zM3 19h18v-2H3v2z" fill="#333"/></svg>
        </span>
        <button class="minimize-btn" data-target="map-legend" aria-label="Minimize legend">−</button>
      </div>
    </div>
    <div class="panel-body">
      <div class="legend-item"><div class="legend-swatch" style="background:#e74c3c"></div><div class="legend-label">Motorway / Train</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#ff6b00"></div><div class="legend-label">Primary roads</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#ffb400"></div><div class="legend-label">Secondary roads</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#f39c12"></div><div class="legend-label">Tertiary roads</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#6c5ce7"></div><div class="legend-label">Residential</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#00b894"></div><div class="legend-label">Living street / Service</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#00cec9"></div><div class="legend-label">Cycleway / Unclassified</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#0984e3"></div><div class="legend-label">Paths / Pedestrian</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#1abc9c"></div><div class="legend-label">Amenities (points)</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#e67e22"></div><div class="legend-label">Buildings (extruded)</div></div>
      <div class="legend-item"><div class="legend-swatch" style="background:#34495e"></div><div class="legend-label">Salzburg boundary</div></div>
    </div>
  </div>

    <div id="proximity-panel" style="display:none; position:absolute; left:12px; top:60px; z-index:4; width:340px; background:#fff; border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.12); padding:12px; font-family:sans-serif;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <strong>Proximity Analysis</strong>
        <button id="proximity-close" style="background:none;border:none;cursor:pointer;font-size:16px">✕</button>
      </div>
      <div style="margin-bottom:8px; color:#444; font-size:13px">Click <strong>Set center</strong> then click the map to pick the center point.</div>
      <div style="display:flex; gap:8px; margin-bottom:8px;">
        <button id="proximity-set-center" style="flex:1;padding:8px;border-radius:4px;border:1px solid rgba(0,0,0,0.12);background:#fff;color:#333;cursor:pointer">Set center</button>
      </div>
      <div id="proximity-info" style="font-size:13px;color:#333;margin-bottom:8px">Center: —  Radius: —</div>
      <div style="display:flex; gap:8px; margin-bottom:8px;">
        <input id="proximity-radius" type="number" min="10" value="5000" style="flex:1;padding:8px;border:1px solid rgba(0,0,0,0.12);border-radius:4px" />
        <select id="proximity-units" style="padding:8px;border:1px solid rgba(0,0,0,0.12);border-radius:4px">
          <option value="meters">m</option>
          <option value="kilometers">km</option>
        </select>
      </div>
      <div style="display:flex; gap:8px; margin-bottom:8px;">
        <button id="proximity-run" style="flex:1;padding:8px;border-radius:4px;border:1px solid rgba(0,0,0,0.12);background:#ccc;color:#999;cursor:not-allowed" disabled>Run</button>
      </div>
      <div id="proximity-summary" style="font-size:13px; color:#222; max-height:220px; overflow:auto; border-top:1px solid rgba(0,0,0,0.04); padding-top:8px"></div>
      <div style="display:flex; gap:8px; margin-top:8px; justify-content:flex-end">
        <button id="proximity-clear" style="padding:6px 10px;border-radius:4px;border:1px solid rgba(0,0,0,0.12);background:#fff;cursor:pointer">Clear</button>
      </div>
    </div>
  <!-- Webmap Title: top right, above layer panel -->
  <div style="position:absolute;top:16px;right:12px;z-index:100;font-family:sans-serif;font-size:1.25rem;font-weight:600;color:#263238;background:rgba(255,255,255,0.96);padding:10px 22px 10px 18px;border-radius:10px 10px 0 0;box-shadow:0 4px 16px rgba(14,30,37,0.10);letter-spacing:0.01em;max-width:420px;text-align:right;">
    MeinSalzburg | Salzburg Urban Toolkit
  </div>
  <div id="layer-panel">
    <h3>Layers</h3>

    <!-- Base maps -->
    <div class="layer-group">
      <div class="layer-header" style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
        <span class="layer-title">Base Maps</span>
        <label style="display:inline-flex;align-items:center;gap:10px;font-size:0.95rem;color:#555;">
          <span style="font-size:0.9rem">3D</span>
          <!-- visually-hidden native checkbox kept for logic; we'll style it as a switch using adjacent spans and JS -->
          <span style="display:inline-block;position:relative;width:40px;height:22px;">
            <input type="checkbox" id="toggle-3d" aria-label="Toggle 3D view" style="position:absolute;opacity:0;width:100%;height:100%;margin:0;left:0;top:0;cursor:pointer;z-index:3;" />
            <span class="switch-bg" style="position:absolute;left:0;top:0;width:100%;height:100%;border-radius:999px;background:#cfd8dc;transition:background .18s, box-shadow .18s;z-index:1;"></span>
            <span class="switch-knob" style="position:absolute;left:3px;top:3px;width:16px;height:16px;border-radius:50%;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,0.3);transition:left .18s, transform .18s;z-index:2;"></span>
          </span>
        </label>
      </div>
      <div class="layer-sub">
        <label style="display:block; margin-bottom:6px;">
          <input type="radio" name="basemap" value="street" checked>
          Street
        </label>
        <label style="display:block;">
          <input type="radio" name="basemap" value="satellite">
          Satellite
        </label>
      </div>
    </div>

    <!-- Export / Controls (moved to map top-left) -->

    <!-- Regions -->
    <div class="layer-group">
      <div class="layer-header">
        <input type="checkbox" id="regions-visible" checked>
        <label for="regions-visible" class="layer-title">Regions</label>
      </div>

      <div class="layer-sub">
        <label class="sub-toggle">
          <input type="checkbox" id="regions-labels-visible" checked>
          Labels
        </label>

        <div class="opacity-row">
          <span>Opacity</span>
          <input type="range" id="regions-opacity" min="0" max="1" step="0.05" value="1">
        </div>
      </div>
    </div>

    <!-- Markers -->
    <div class="layer-group">
      <div class="layer-header">
        <span class="layer-title">Markers</span>
      </div>

      <div class="layer-sub">
        <label class="sub-toggle">
          <input type="checkbox" id="marker-default-visible" checked>
          Default Marker
        </label>

        <label class="sub-toggle">
          <input type="checkbox" id="marker-png-visible" checked>
          PNG Marker
        </label>

        <label class="sub-toggle">
          <input type="checkbox" id="marker-html-visible" checked>
          HTML Marker
        </label>
      </div>
    </div>
    
    <!-- Data sources / credits -->
    <div class="layer-group" style="margin-top:10px; font-size:13px;">
      <div class="layer-header">
        <span class="layer-title">Data sources</span>
      </div>
      <div class="layer-sub" style="padding:6px 4px; color:#333;">
        <!-- Logos: your files were detected in the local 'logo/' folder; update names here if needed -->
        <div class="data-logos">
          <img src="logo/logo_cde.jpg" alt="Copernicus Master in Digital Earth logo">
          <img src="logo/uni-sbg-logo.png" alt="Paris Lodron University Olomouc logo">
          <img src="logo/upol_logo.png" alt="Palacký University Olomouc logo">
        </div>
        <div class="data-credit" style="margin-top:8px; color:#333; font-size:13px;">
          Map tiles © <a href="https://www.openstreetmap.org/" target="_blank" rel="noopener">OpenStreetMap contributors</a>
          &nbsp;|&nbsp; Satellite © <a href="https://www.esri.com/en-us/home" target="_blank" rel="noopener">Esri</a>
          &nbsp;|&nbsp; Data: <a href="data/austria-demography-simplified-wgs84.geojson" target="_blank">Austria demography (GeoJSON)</a>
          &nbsp;|&nbsp; Icons: <code>marker.png</code>
        </div>
        <div style="margin-top:6px; color:#666; font-size:12px;">Please respect each provider's terms of use and attribution requirements.</div>
      </div>
    </div>
    </div>
  </div>


  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script>
    //map initialization
    // Use a minimal/empty style so our raster OSM layer becomes the visible basemap
    const map = new maplibregl.Map({
      container: "map",
      style: {
        version: 8,
        sources: {},
        layers: []
      },
      center: [13.0449, 48.2699],
      zoom: 12,
      pitch: 45
    });

    // ------------------------- Simple Nominatim search -------------------------
    let searchMarker = null;

    // debounce helper
    function debounce(fn, wait) {
      let t = null;
      return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), wait);
      };
    }

    const input = document.getElementById('search-input');
    const resultsDiv = document.getElementById('search-results');

    async function doSearch(query) {
      if (!query || query.length < 3) {
        resultsDiv.innerHTML = '';
        return;
      }

      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=6&q=${encodeURIComponent(query)}`;
      try {
        const res = await fetch(url, {
          headers: { 'Accept-Language': 'en' }
        });
        const json = await res.json();
        renderResults(json);
      } catch (err) {
        console.error('Search error', err);
        resultsDiv.innerHTML = '';
      }
    }

    function renderResults(items) {
      if (!items || !items.length) {
        resultsDiv.innerHTML = '';
        return;
      }

      resultsDiv.innerHTML = items.map((it, i) =>
        `<div class="search-item" data-lon="${it.lon}" data-lat="${it.lat}">${it.display_name}</div>`
      ).join('');

      // attach click handlers
      Array.from(resultsDiv.querySelectorAll('.search-item')).forEach(el => {
        el.addEventListener('click', () => {
          const lon = parseFloat(el.getAttribute('data-lon'));
          const lat = parseFloat(el.getAttribute('data-lat'));
          // fly to place
          map.flyTo({ center: [lon, lat], zoom: 13 });

          // add or move marker
          if (!searchMarker) {
            searchMarker = new maplibregl.Marker({ color: '#ff5722' }).setLngLat([lon, lat]).addTo(map);
          } else {
            searchMarker.setLngLat([lon, lat]);
          }

          resultsDiv.innerHTML = '';
          input.value = '';
        });
      });
    }

    const debouncedSearch = debounce((e) => doSearch(e.target.value), 300);
    input.addEventListener('input', debouncedSearch);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        resultsDiv.innerHTML = '';
        input.value = '';
      }
    });


    
    // ------------------------------------Data Sources and Layers------------------------------------  //
    // Load all GeoJSON data sources and add them as layers
      // Add all GeoJSON sources
    // ------------------------------------choropleth layer------------------------------------  //
    // Add DEM source + enable 3D terrain, then GeoJSON source and layers
    map.on("load", () => {
      // Add a raster-dem source using the free Terrarium tiles hosted on S3.
      // This source does not require an API key and uses the "terrarium" encoding.
      map.addSource('dem', {
        type: 'raster-dem',
        tiles: [
          'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        maxzoom: 15,
        encoding: 'terrarium'
      });

      // Enable 3D terrain and raise exaggeration so relief is visible.
      // Increase the `exaggeration` value if you want a stronger effect.
      map.setTerrain({ source: 'dem', exaggeration: 1.2});

      // Add a simple sky layer for a nicer 3D appearance
      map.addLayer({
        id: 'sky',
        type: 'sky',
        paint: {
          'sky-type': 'atmosphere',
          'sky-atmosphere-sun': [0.0, 45.0],
          'sky-atmosphere-sun-intensity': 15
        }
      });

      // --- Base map raster sources & layers (Street and Satellite) - ADD FIRST SO THEY'RE BELOW ---
      // Street (OpenStreetMap)
      map.addSource('basemap-street-source', {
        type: 'raster',
        // use explicit subdomain URLs (a, b, c) instead of a range placeholder
        tiles: [
          'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        attribution: '© OpenStreetMap contributors'
      });

      // Satellite (Esri World Imagery)
      map.addSource('basemap-satellite-source', {
        type: 'raster',
        tiles: [
          'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
        ],
        tileSize: 256,
        attribution: 'Tiles © Esri'
      });

      // Add street raster layer (visible by default)
      map.addLayer({
        id: 'basemap-street',
        type: 'raster',
        source: 'basemap-street-source'
      });

      // Add satellite raster layer (hidden by default)
      map.addLayer({
        id: 'basemap-satellite',
        type: 'raster',
        source: 'basemap-satellite-source',
        layout: { 'visibility': 'none' }
      });

      map.addSource("amenities", {
        type: "geojson",
        data: "data/amenities.geojson"
      });

      map.addSource("buildings", {
        type: "geojson",
        data: "data/buildings.geojson"
      });

      map.addSource("railway", {
        type: "geojson",
        data: "data/railway.geojson"
      });

      map.addSource("salzburg-boundaries", {
        type: "geojson",
        data: "data/Salzburg_Boundaries.geojson"
      });

      map.addSource("streets", {
        type: "geojson",
        data: "data/streets.geojson"
      });

      /*map.addSource("train", {
        type: "geojson",
        data: "data/train.geojson"
      });*/

      // Add layers for amenities (points) - new color theme
      map.addLayer({
        id: "amenities-layer",
        type: "circle",
        source: "amenities",
        paint: {
          "circle-radius": 6,
          "circle-color": "#1abc9c",
          "circle-opacity": 0.9
        }
      });

      // Add extruded buildings (small height) to give subtle 3D
      map.addLayer({
        id: "buildings-layer",
        type: "fill-extrusion",
        source: "buildings",
        paint: {
          "fill-extrusion-color": "#e67e22",
          // Compute height from building:levels (levels * 3m). Use a higher
          // fallback (3 levels) and enforce a visible minimum height (6m).
          // Expression: max( coalesce(to-number(get('building:levels')), 3) * 3, 6 )
          "fill-extrusion-height": [
            "max",
            [
              "*",
              ["coalesce", ["to-number", ["get", "building:levels"]], 3],
              3
            ],
            6
          ],
          "fill-extrusion-base": 0,
          "fill-extrusion-opacity": 0.95
        }
      });

      // Add stroke/outline for buildings (keeps map readable at low zoom)
      map.addLayer({
        id: "buildings-outline",
        type: "line",
        source: "buildings",
        paint: {
          "line-color": "#d35400",
          "line-width": 1
        }
      });

      // Add layers for railway (lines)
      map.addLayer({
        id: "railway-layer",
        type: "line",
        source: "railway",
        paint: {
          "line-color": "#3498db",
          "line-width": 1
        }
      });

      // Add layers for Salzburg boundaries: transparent interior, visible border only
      map.addLayer({
        id: "salzburg-boundaries-layer",
        type: "fill",
        source: "salzburg-boundaries",
        paint: {
          // keep interior fully transparent so it doesn't interfere with popups
          "fill-color": "rgba(0,0,0,0)",
          "fill-opacity": 0
        }
      });

      // Outline for Salzburg boundaries (visible)
      map.addLayer({
        id: "salzburg-boundaries-outline",
        type: "line",
        source: "salzburg-boundaries",
        paint: {
          "line-color": "#34495e",
          "line-width": 2
        }
      });

      // Streets types Coloring - IMPORTANT theme
      map.addLayer({
        id: "streets-layer",
        type: "line",
        source: "streets",
        paint: {
          // Color by highway type (lively palette). Default gray if not matched.
          "line-color": [
            "match",
            ["get", "highway"],
            "motorway", "#e74c3c",
            "motorway_link", "#e74c3c",
            "primary", "#ff6b00",
            "secondary", "#ffb400",
            "tertiary", "#f39c12",
            "primary_link", "#ff6b00",
            "tertiary_link", "#f39c12",
            "residential", "#6c5ce7",
            "living_street", "#00b894",
            "service", "#00b894",
            "unclassified", "#00cec9",
            "cycleway", "#00cec9",
            "path", "#0984e3",
            "pedestrian", "#0984e3",
            "#95a5a6"
          ],
          // Widths: larger for main roads, smaller for paths
          "line-width": [
            "match",
            ["get", "highway"],
            "motorway", 5,
            "motorway_link", 4.5,
            "primary", 4,
            "primary_link", 3.8,
            "secondary", 3,
            "tertiary", 2.4,
            "tertiary_link", 2.2,
            "residential", 1.8,
            "living_street", 1.6,
            "service", 1.4,
            "unclassified", 1.2,
            "cycleway", 1.2,
            "path", 1,
            "pedestrian", 1,
            1.2
          ]
        }
      });

      map.addLayer({
        id: "train-layer",
        type: "circle",
        source: "train",
        paint: {
          "circle-radius": 8,
          "circle-color": "#e74c3c",
          "circle-opacity": 0.95,
          "circle-stroke-color": "#b03a2e",
          "circle-stroke-width": 1
        }
      });

      // Wire up radio buttons to toggle the base layers
      const basemapRadios = document.querySelectorAll('input[name="basemap"]');
      basemapRadios.forEach(r => r.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'street') {
          map.setLayoutProperty('basemap-street', 'visibility', 'visible');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'none');
        } else if (val === 'satellite') {
          map.setLayoutProperty('basemap-street', 'visibility', 'none');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'visible');
        }
      }));

      // 2D / 3D toggle: wire the checkbox placed in the Base Maps header
      const toggle3d = document.getElementById('toggle-3d');
      if (toggle3d) {
        const switchBg = toggle3d.parentElement.querySelector('.switch-bg');
        const switchKnob = toggle3d.parentElement.querySelector('.switch-knob');

        function updateSwitchVisual(checked) {
          if (!switchBg || !switchKnob) return;
          if (checked) {
            switchBg.style.background = '#1978c8';
            switchBg.style.boxShadow = '0 2px 6px rgba(25,120,200,0.28)';
            switchKnob.style.left = '21px';
            switchKnob.style.transform = 'translateX(0)';
          } else {
            switchBg.style.background = '#cfd8dc';
            switchBg.style.boxShadow = 'none';
            switchKnob.style.left = '3px';
            switchKnob.style.transform = 'none';
          }
        }

        // default: map was initialized with terrain enabled earlier; reflect that in the switch
        try { toggle3d.checked = true; } catch (e) {}
        updateSwitchVisual(toggle3d.checked);

        toggle3d.addEventListener('change', function() {
          updateSwitchVisual(this.checked);
          if (this.checked) {
            // enable terrain and set a pleasing pitch
            try {
              map.setTerrain({ source: 'dem', exaggeration: 1.2 });
            } catch (e) {}
            map.easeTo({ pitch: 45, duration: 600 });
          } else {
            // disable terrain and reset to flat 2D
            try {
              map.setTerrain(null);
            } catch (e) {}
            map.easeTo({ pitch: 0, duration: 600 });
          }
        });
      }

    }); 


    //------------------------------------markers------------------------------------  //
      //default marker start
      const markerDefault = new maplibregl.Marker()
        .setLngLat([16.3725, 48.2084]);

      markerDefault.addTo(map);
      //default marker end

      //custom marker png start
      const el = document.createElement("div");
      const img = document.createElement("img");
      img.src = "./marker.png";
      img.style.width = "25px";
      img.style.height = "40px";
      el.appendChild(img);

      const markerPNG  = new maplibregl.Marker({ element: el })
        .setLngLat([16.0725, 48.0084])
        .addTo(map);
      //custom marker png end


      //html marker start
      const el1 = document.createElement("div");
      el1.innerHTML = `
        <div style="
            background:#ff5722;
            color:white;
            padding:4px 8px;
            border-radius:6px;
            font-size:12px;
        ">HTML Marker</div>
      `;
      const markerHTML = new maplibregl.Marker({ element: el1 })
        .setLngLat([15.8725, 48.2084])
        .addTo(map);
      //html marker end

      // marker for user's location (set when Find my location is used)
      let locationMarker = null;

      
     // -------------------------------marker popups-----------------------------------------  // 
      // prevent polygon click when point marker is clicked
      markerPNG.getElement().addEventListener("click", (e) => {
        e.stopPropagation();       // prevents polygon popup
        markerPNG.togglePopup();      // shows marker popup
      });

      //marker popup simple way to set popup
      const popup = new maplibregl.Popup({ offset: 25 })
        .setHTML("<h3>Marker Info</h3><p>This is a PNG marker.</p>");

      // Attach popup to marker
      markerPNG.setPopup(popup);


      // Function to build popup HTML content
      function buildPopupHTML(properties) {
        const name = properties.NAME || properties.name || null;

        // Create table rows for all properties except NAME
        const rows = Object.entries(properties)
        .filter(([key]) => key.toLowerCase() !== "name")
        .map(
          ([key, value], i) => `
            <tr style="background:${i % 2 ? "#eddbdb" : "#ffffff"}">
              <td style="padding:4px 6px; color: #272727"><strong>${key}</strong></td>
              <td style="padding:4px 6px;">${value}</td>
            </tr>
          `
        )
        .join("");


        return `
          <div style="
            max-width: 260px;
            font-family: sans-serif;
          ">
            ${name ? `<h3 style="
                margin: 0 0 8px 0;
                font-size: 16px;
                font-weight: bold;
                border-bottom: 1px solid #ccc;
                padding: 7px;
                background: #eccaca;
                color: #272727;
            ">${name}</h3>` : ""}

            <div style="
              max-height: 150px;
              overflow-y: auto;
              border: 1px solid #ddd;
              border-radius: 4px;
            ">
              <table style="
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
              ">
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        `;
    }

    // Add click events for layers to show popups (excluding salzburg-boundaries-layer)
    const layersWithPopups = [
      "amenities-layer",
      "buildings-layer",
      "railway-layer",
      "streets-layer",
      "train-layer"
    ];

    layersWithPopups.forEach(layerId => {
      map.on("click", layerId, (e) => {
        const props = e.features[0].properties;
        new maplibregl.Popup({ closeButton: true })
          .setLngLat(e.lngLat)
          .setHTML(buildPopupHTML(props))
          .addTo(map);
      });
    });

    // Handle clicks for all layers with layer selection if multiple layers at click point
    // Exclude Salzburg boundary layers from interactive queries so the transparent interior
    // does not appear in popups or the layer dropdown.
    const allInteractiveLayers = [
      "amenities-layer",
      "buildings-layer",
      "railway-layer",
      "streets-layer",
      "train-layer"
    ];

    map.on("click", (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: allInteractiveLayers
      });

      if (features.length > 0) {
        // Get unique layers at this point
        const uniqueLayers = [...new Set(features.map(f => f.layer.id))];
        
        // Find the top layer (first in the list)
        const topLayerId = uniqueLayers[0];
        const topFeature = features.find(f => f.layer.id === topLayerId);
        
        // Only show popup if top layer is not salzburg boundaries
        if (topLayerId !== "salzburg-boundaries-layer" && topLayerId !== "salzburg-boundaries-outline") {
          let popupHTML = buildPopupHTML(topFeature.properties);
          
          // Add dropdown if multiple layers
          if (uniqueLayers.length > 1) {
            const dropdownOptions = uniqueLayers.map((layerId, idx) => `
              <option value="${idx}" ${idx === 0 ? 'selected' : ''}>
                ${layerId.replace('-layer', '').replace('-outline', ' outline')}
              </option>
            `).join('');
            
            popupHTML += `
              <div style="margin-top:10px; padding-top:10px; border-top:1px solid #ddd;">
                <label style="font-size:12px; display:block; margin-bottom:4px;"><strong>Other layers:</strong></label>
                <select class="layer-dropdown" style="width:100%; padding:6px; border:1px solid #ccc; border-radius:4px; font-size:12px;">
                  ${dropdownOptions}
                </select>
              </div>
            `;
          }
          
          const popup = new maplibregl.Popup({ closeButton: true })
            .setLngLat(e.lngLat)
            .setHTML(popupHTML)
            .addTo(map);
          
          // Add dropdown change handler if multiple layers
          if (uniqueLayers.length > 1) {
            setTimeout(() => {
              const dropdown = document.querySelector('.layer-dropdown');
              if (dropdown) {
                dropdown.addEventListener('change', (evt) => {
                  const selectedIdx = parseInt(evt.target.value);
                  const selectedLayerId = uniqueLayers[selectedIdx];
                  const selectedFeature = features.find(f => f.layer.id === selectedLayerId);
                  
                  if (selectedFeature && selectedLayerId !== "salzburg-boundaries-layer" && selectedLayerId !== "salzburg-boundaries-outline") {
                    popup.remove();
                    let newPopupHTML = buildPopupHTML(selectedFeature.properties);
                    
                    // Re-add dropdown with updated selection
                    const dropdownOptions = uniqueLayers.map((layerId, idx) => `
                      <option value="${idx}" ${idx === selectedIdx ? 'selected' : ''}>
                        ${layerId.replace('-layer', '').replace('-outline', ' outline')}
                      </option>
                    `).join('');
                    
                    newPopupHTML += `
                      <div style="margin-top:10px; padding-top:10px; border-top:1px solid #ddd;">
                        <label style="font-size:12px; display:block; margin-bottom:4px;"><strong>Other layers:</strong></label>
                        <select class="layer-dropdown" style="width:100%; padding:6px; border:1px solid #ccc; border-radius:4px; font-size:12px;">
                          ${dropdownOptions}
                        </select>
                      </div>
                    `;
                    
                    const newPopup = new maplibregl.Popup({ closeButton: true })
                      .setLngLat(e.lngLat)
                      .setHTML(newPopupHTML)
                      .addTo(map);
                    
                    setTimeout(() => {
                      const newDropdown = document.querySelector('.layer-dropdown');
                      if (newDropdown) {
                        newDropdown.addEventListener('change', arguments.callee);
                      }
                    }, 0);
                  }
                });
              }
            }, 0);
          }
        }
      }
    });


    //--------------------------------mouseover effect------------------------------------  //
    // Hover effects removed - old regions-fill layer no longer exists



    //--------------------------------cursor pointer on layers during hover------------------------------------  //
    // Change cursor to pointer when hovering over interactive layers
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: ["amenities-layer", "buildings-layer", "railway-layer", "streets-layer", "train-layer"]
      });

      if (features.length) {
        map.getCanvas().style.cursor = "pointer";
      } else {
        map.getCanvas().style.cursor = "";
      }
    });

    // Setup marker cursors after map load
    map.on("load", () => {

    
      markerDefault.getElement().style.cursor = "pointer";
      markerPNG.getElement().style.cursor = "pointer";  
      markerHTML.getElement().style.cursor = "pointer";



      // Add scale control (like Google Maps)
      const scale = new maplibregl.ScaleControl({
        maxWidth: 140,
        unit: "metric" // use 'imperial' for miles, 'nautical' for nautical miles
      });
      map.addControl(scale, "bottom-right");
    });

    // ---------------------- Proximity analysis logic ----------------------
    let regionsGeo = null;
    fetch('data/austria-demography-simplified-wgs84.geojson')
      .then(r => r.json())
      .then(j => { regionsGeo = j; })
      .catch(err => { console.warn('Could not load regions GeoJSON for proximity:', err); });

    const proximityOpen = document.getElementById('proximity-open');
    const proximityPanel = document.getElementById('proximity-panel');
    const proximityClose = document.getElementById('proximity-close');
    const setCenterBtn = document.getElementById('proximity-set-center');
    const runBtn = document.getElementById('proximity-run');
    const clearBtn = document.getElementById('proximity-clear');
    const radiusInput = document.getElementById('proximity-radius');
    const unitsSelect = document.getElementById('proximity-units');
    const summaryDiv = document.getElementById('proximity-summary');
    const infoDiv = document.getElementById('proximity-info');

    let proximityCenter = null; // {lng, lat}

    function updateProximityInfo() {
      const val = parseFloat(radiusInput.value) || 0;
      const units = unitsSelect.value === 'kilometers' ? 'km' : 'm';
      const coords = proximityCenter ? `${proximityCenter.lat.toFixed(5)}, ${proximityCenter.lng.toFixed(5)}` : '\u2014';
      infoDiv.textContent = `Center: ${coords}  Radius: ${val} ${units}`;
    }

    function showPanel() { proximityPanel.style.display = 'block'; }
    function hidePanel() { proximityPanel.style.display = 'none'; }

    proximityOpen.addEventListener('click', () => {
      showPanel();
    });
    proximityClose.addEventListener('click', () => { hidePanel(); });

    function clearProximity() {
      if (map.getLayer('proximity-fill')) map.removeLayer('proximity-fill');
      if (map.getLayer('proximity-outline')) map.removeLayer('proximity-outline');
      if (map.getSource('proximity')) map.removeSource('proximity');
      summaryDiv.innerHTML = '';
      proximityCenter = null;
      updateProximityInfo();
      // Disable Run button when clearing
      runBtn.disabled = true;
      runBtn.style.background = '#ccc';
      runBtn.style.color = '#999';
      runBtn.style.cursor = 'not-allowed';
    }

    clearBtn.addEventListener('click', () => { clearProximity(); });

    // update info when radius or units change
    radiusInput.addEventListener('input', () => updateProximityInfo());
    unitsSelect.addEventListener('change', () => updateProximityInfo());

    setCenterBtn.addEventListener('click', () => {
      summaryDiv.innerHTML = '<div style="color:#666;font-size:13px">Click on the map to set the center point...</div>';
      map.getCanvas().style.cursor = 'crosshair';
      map.once('click', (e) => {
        map.getCanvas().style.cursor = '';
        proximityCenter = e.lngLat;
        updateProximityInfo();
        drawProximityCircle();
        // Enable Run button after center is selected
        runBtn.disabled = false;
        runBtn.style.background = '#1978c8';
        runBtn.style.color = '#fff';
        runBtn.style.cursor = 'pointer';
      });
    });

    function drawProximityCircle() {
      if (!proximityCenter) return;
      const val = parseFloat(radiusInput.value) || 0;
      const units = unitsSelect.value === 'kilometers' ? 'kilometers' : 'meters';
      const radiusKm = units === 'kilometers' ? val : val / 1000;

      const centerCoord = [proximityCenter.lng, proximityCenter.lat];
      const circle = turf.circle(centerCoord, radiusKm, { steps: 128, units: 'kilometers' });

      if (map.getSource('proximity')) {
        map.getSource('proximity').setData(circle);
      } else {
        map.addSource('proximity', { type: 'geojson', data: circle });
        map.addLayer({
          id: 'proximity-fill',
          type: 'fill',
          source: 'proximity',
          paint: { 'fill-color': '#1978c8', 'fill-opacity': 0.18 }
        });
        map.addLayer({
          id: 'proximity-outline',
          type: 'line',
          source: 'proximity',
          paint: { 'line-color': '#1978c8', 'line-width': 2 }
        });
      }
      updateProximityInfo();
    }

    runBtn.addEventListener('click', () => {
      if (!proximityCenter) {
        summaryDiv.innerHTML = '<div style="color:#b00">Set a center point first.</div>';
        return;
      }

      // ensure circle is drawn/updated
      drawProximityCircle();

      const val = parseFloat(radiusInput.value) || 0;
      const units = unitsSelect.value === 'kilometers' ? 'kilometers' : 'meters';
      const radiusKm = units === 'kilometers' ? val : val / 1000;

      const centerPt = turf.point([proximityCenter.lng, proximityCenter.lat]);
      const circlePoly = turf.circle([proximityCenter.lng, proximityCenter.lat], radiusKm, { steps: 128, units: 'kilometers' });

      // markers: markerDefault, markerPNG, markerHTML
      const markerCounts = [];
      const markers = [
        { id: 'Default Marker', obj: markerDefault },
        { id: 'PNG Marker', obj: markerPNG },
        { id: 'HTML Marker', obj: markerHTML }
      ];

      markers.forEach(m => {
        let inside = false;
        try {
          const ll = m.obj.getLngLat();
          const mp = turf.point([ll.lng, ll.lat]);
          const dist = turf.distance(centerPt, mp, { units: 'kilometers' });
          if (dist <= radiusKm) inside = true;
        } catch (e) {
          inside = false;
        }
        markerCounts.push({ id: m.id, inside });
      });

      // regions
      let regionsInside = [];
      if (regionsGeo && regionsGeo.features) {
        regionsGeo.features.forEach(f => {
          try {
            if (turf.booleanIntersects(circlePoly, f)) {
              regionsInside.push(f);
            }
          } catch (e) {
            // ignore
          }
        });
      }

      // Build summary HTML
      const lines = [];
      lines.push(`<div style="font-weight:600;margin-bottom:6px">Summary</div>`);
      lines.push(`<div style="font-size:13px;margin-bottom:6px">Center: ${proximityCenter.lat.toFixed(5)}, ${proximityCenter.lng.toFixed(5)} — Radius: ${val} ${units === 'kilometers' ? 'km' : 'm'}</div>`);

      // markers
      lines.push('<div style="margin-top:6px"><strong>Markers</strong></div>');
      markerCounts.forEach(m => {
        lines.push(`<div style="font-size:13px;padding:3px 0">${m.id}: <strong style="color:${m.inside ? '#1978c8' : '#777'}">${m.inside ? 'inside' : 'outside'}</strong></div>`);
      });

      // regions
      lines.push('<div style="margin-top:8px"><strong>Regions</strong></div>');
      lines.push(`<div style="font-size:13px;padding:3px 0">Count inside: <strong>${regionsInside.length}</strong></div>`);
      if (regionsInside.length) {
        lines.push('<div style="max-height:120px; overflow:auto; border-top:1px solid rgba(0,0,0,0.03); margin-top:6px; padding-top:6px">');
        regionsInside.slice(0,50).forEach(r => {
          const name = r.properties && (r.properties.NAME || r.properties.name || '')
          lines.push(`<div style="font-size:13px;padding:4px 0;border-bottom:1px dashed rgba(0,0,0,0.04)">${name}</div>`);
        });
        if (regionsInside.length > 50) lines.push(`<div style="font-size:12px;color:#666;padding:6px 0">+${regionsInside.length-50} more</div>`);
        lines.push('</div>');
      }

      summaryDiv.innerHTML = lines.join('');
    });
    // Export / Locate / Zoom functions (used by map controls)
    function exportMapPNG() {
      // kept for backwards compatibility
      exportMap('png');
    }

    // Unified export function supporting png, jpeg and pdf
    async function exportMap(format = 'png') {
      try {
        // Prefer capturing the full page using html2canvas (works even when map canvas is tainted)
        if (window.html2canvas) {
          try {
            const opts = { useCORS: true, logging: false, scale: Math.max(1, window.devicePixelRatio || 1) };
            const pageCanvas = await html2canvas(document.body, opts);

            if (format === 'pdf') {
              const dataUrl = pageCanvas.toDataURL('image/png');
              const jsPDFClass = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jsPDF ? window.jsPDF : null);
              if (!jsPDFClass) {
                alert('PDF export requires jsPDF. Please check your internet connection.');
                return;
              }
              const img = new Image();
              img.src = dataUrl;
              img.onload = () => {
                const imgW = img.width;
                const imgH = img.height;
                const imgRatio = imgW / imgH;
                const pdf = new jsPDFClass({ unit: 'pt', format: 'a4' });
                const pageW = pdf.internal.pageSize.getWidth();
                const pageH = pdf.internal.pageSize.getHeight();
                let renderW = pageW;
                let renderH = pageW / imgRatio;
                if (renderH > pageH) { renderH = pageH; renderW = pageH * imgRatio; }
                const marginX = (pageW - renderW) / 2;
                const marginY = (pageH - renderH) / 2;
                pdf.addImage(dataUrl, 'PNG', marginX, marginY, renderW, renderH);
                pdf.save('map.pdf');
              };
              img.onerror = (e) => { console.error('PDF image load error', e); alert('PDF export failed (image load).'); };
              return;
            }

            // PNG / JPEG
            const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
            const quality = format === 'jpeg' ? 0.92 : undefined;
            if (pageCanvas.toBlob) {
              pageCanvas.toBlob((blob) => {
                if (!blob) throw new Error('Failed to generate image blob');
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`;
                document.body.appendChild(link);
                link.click();
                link.remove();
                setTimeout(() => URL.revokeObjectURL(url), 1000);
              }, mime, quality);
            } else {
              const dataUrl = mime === 'image/png' ? pageCanvas.toDataURL('image/png') : pageCanvas.toDataURL('image/jpeg', quality);
              const link = document.createElement('a');
              link.href = dataUrl;
              link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`;
              document.body.appendChild(link);
              link.click();
              link.remove();
            }
            return;
          } catch (e) {
            console.warn('html2canvas capture failed, falling back to map canvas capture', e);
            // fallthrough to map canvas approach below
          }
        }

        // Fallback: export map canvas (may fail if canvas is tainted by cross-origin tiles)
        const canvas = map.getCanvas();
        if (!canvas) throw new Error('Map canvas not available');

        if (format === 'pdf') {
          const dataUrl = canvas.toDataURL('image/png');
          const jsPDFClass = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jsPDF ? window.jsPDF : null);
          if (!jsPDFClass) { alert('PDF export requires jsPDF. Please check your internet connection.'); return; }
          const img = new Image();
          img.src = dataUrl;
          img.onload = () => {
            const imgW = img.width; const imgH = img.height; const imgRatio = imgW / imgH;
            const pdf = new jsPDFClass({ unit: 'pt', format: 'a4' });
            const pageW = pdf.internal.pageSize.getWidth(); const pageH = pdf.internal.pageSize.getHeight();
            let renderW = pageW; let renderH = pageW / imgRatio;
            if (renderH > pageH) { renderH = pageH; renderW = pageH * imgRatio; }
            const marginX = (pageW - renderW) / 2; const marginY = (pageH - renderH) / 2;
            pdf.addImage(dataUrl, 'PNG', marginX, marginY, renderW, renderH); pdf.save('map.pdf');
          };
          img.onerror = (e) => { console.error('Image load error for PDF export', e); alert('PDF export failed (image load).'); };
          return;
        }

        const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
        const quality = format === 'jpeg' ? 0.92 : undefined;
        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (!blob) throw new Error('Failed to generate image blob');
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url; link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`; document.body.appendChild(link); link.click(); link.remove(); setTimeout(() => URL.revokeObjectURL(url), 1000);
          }, mime, quality);
        } else {
          const dataUrl = mime === 'image/png' ? canvas.toDataURL('image/png') : canvas.toDataURL('image/jpeg', quality);
          const link = document.createElement('a'); link.href = dataUrl; link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`; document.body.appendChild(link); link.click(); link.remove();
        }
      } catch (err) {
        console.error('Export failed:', err);
        alert('Export failed. This usually happens when map tiles are loaded from servers that do not send CORS headers, which taints the canvas and prevents image export.\n\nPossible fixes:\n- Use a tile provider that supports CORS (with Access-Control-Allow-Origin).\n- Run a local tile proxy or self-host tiles.\n- Use a hosted map style that allows exporting.\n\nSee the console for the exact error.');
      }

    }

    // Create a Google-like location marker (SVG teardrop with white center)
    function createLocationMarkerElement() {
      const wrapper = document.createElement('div');
      wrapper.style.width = '36px';
      wrapper.style.height = '36px';
      wrapper.style.display = 'inline-block';
      wrapper.style.pointerEvents = 'none'; // let clicks pass through to map if needed

      // Circular location marker: subtle red glow, white border, red core
      wrapper.innerHTML = `
        <svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
          <!-- white border ring -->
          <circle cx="18" cy="18" r="11" fill="#ffffff" />
          <!-- red inner ring -->
          <circle cx="18" cy="18" r="7.5" fill="#ff4d4d" />
          <!-- darker red core -->
          <circle cx="18" cy="18" r="3" fill="#b30000" />
        </svg>
      `;
      return wrapper;
    }

    // Convert meters to pixels at given latitude & zoom for WebMercator / MapLibre
    function metersToPixelsAtZoom(meters, latitude, zoom) {
      const earthCircumference = 40075016.686; // meters
      const latRad = latitude * Math.PI / 180;
      // formula: metersPerPixel = earthCircumference * cos(lat) / 2^(zoom + 8)
      const metersPerPixel = earthCircumference * Math.cos(latRad) / Math.pow(2, zoom + 8);
      return meters / metersPerPixel;
    }

    async function findMyLocation(triggerButton) {
      if (!('geolocation' in navigator)) {
        alert('Geolocation is not available in this browser.');
        return;
      }

      const btn = triggerButton || null;
      if (btn) {
        btn.disabled = true;
        // preserve the button icon HTML and show a small busy indicator (keep icon visible)
        var originalHTML = btn.innerHTML;
        btn.innerHTML = originalHTML + ' <span aria-hidden="true">⏳</span>';
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lng = pos.coords.longitude;
          const lat = pos.coords.latitude;
          const accuracy = pos.coords.accuracy || 0; // meters

          map.flyTo({ center: [lng, lat], zoom: 14, speed: 1.2 });

          // Create or update the SVG marker
          if (locationMarker) {
            locationMarker.setLngLat([lng, lat]);
          } else {
            const el = createLocationMarkerElement();
            locationMarker = new maplibregl.Marker({ element: el, anchor: 'bottom' })
              .setLngLat([lng, lat])
              .addTo(map);
          }

          // Add / update an accuracy circle as a GeoJSON source + circle layer
          const accuracySourceId = 'location-accuracy-src';
          const accuracyLayerId = 'location-accuracy-layer';
          const pointGeoJSON = {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [lng, lat] },
            properties: { accuracy: accuracy }
          };

          if (!map.getSource(accuracySourceId)) {
            map.addSource(accuracySourceId, { type: 'geojson', data: pointGeoJSON });
            map.addLayer({
              id: accuracyLayerId,
              type: 'circle',
              source: accuracySourceId,
              paint: {
                  // keep a subtle red fill only (remove the outer stroke) and make it small by default
                  'circle-color': '#ff6b5c',
                  'circle-opacity': 0.12
                }
            });
          } else {
            map.getSource(accuracySourceId).setData(pointGeoJSON);
          }

          // compute and set radius in pixels for the current zoom
          // reduce the visible accuracy buffer size so the outer buffer is much smaller
          const pix = metersToPixelsAtZoom(accuracy, lat, map.getZoom()) * 0.5;
          if (map.getLayer(accuracyLayerId)) {
            map.setPaintProperty(accuracyLayerId, 'circle-radius', pix);
          }

          // store latest accuracy data for zoom handler
          window._locationAccuracy = { lat, accuracy };

          // ensure we update the pixel radius on zoom changes (one-time hookup)
          if (!map._locationAccuracyHandler) {
            map._locationAccuracyHandler = function () {
              const a = window._locationAccuracy;
              if (!a) return;
              // apply same reduced scale when zooming so buffer remains smaller
              const newPix = metersToPixelsAtZoom(a.accuracy, a.lat, map.getZoom()) * 0.5;
              if (map.getLayer(accuracyLayerId)) {
                map.setPaintProperty(accuracyLayerId, 'circle-radius', newPix);
              }
            };
            map.on('zoom', map._locationAccuracyHandler);
          }

          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
          }
        },
        (err) => {
          console.error('Geolocation error:', err);
          alert('Unable to retrieve your location: ' + (err.message || err.code));
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
          }
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    async function zoomToExtent() {
      try {
        const url = 'data/austria-demography-simplified-wgs84.geojson';
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('Failed to fetch GeoJSON: ' + resp.status);
        const geojson = await resp.json();

        function updateBBoxFromCoords(coords, bbox) {
          if (typeof coords[0] === 'number' && coords.length >= 2) {
            const lng = coords[0];
            const lat = coords[1];
            if (lng < bbox[0]) bbox[0] = lng;
            if (lat < bbox[1]) bbox[1] = lat;
            if (lng > bbox[2]) bbox[2] = lng;
            if (lat > bbox[3]) bbox[3] = lat;
          } else if (Array.isArray(coords)) {
            coords.forEach(c => updateBBoxFromCoords(c, bbox));
          }
        }

        function bboxOfGeoJSON(gj) {
          const bbox = [Infinity, Infinity, -Infinity, -Infinity];
          if (gj.type === 'FeatureCollection') {
            gj.features.forEach(f => {
              if (f.geometry) updateBBoxFromCoords(f.geometry.coordinates, bbox);
            });
          } else if (gj.type === 'Feature' && gj.geometry) {
            updateBBoxFromCoords(gj.geometry.coordinates, bbox);
          } else if (gj.type === 'GeometryCollection' && gj.geometries) {
            gj.geometries.forEach(g => updateBBoxFromCoords(g.coordinates, bbox));
          } else if (gj.coordinates) {
            updateBBoxFromCoords(gj.coordinates, bbox);
          }
          if (bbox[0] === Infinity) return null;
          return [[bbox[0], bbox[1]], [bbox[2], bbox[3]]];
        }

        const bounds = bboxOfGeoJSON(geojson);
        if (!bounds) {
          alert('Could not compute bounds for the GeoJSON.');
          return;
        }

        map.fitBounds(bounds, { padding: 20, maxZoom: 14, duration: 800 });
      } catch (err) {
        console.error('Zoom to extent failed:', err);
        alert('Zoom to extent failed. Check the console for details.');
      }
    }

    // attach to any existing panel buttons if present (we removed panel buttons by default)
    const exportBtn = document.getElementById('export-map');
    if (exportBtn) exportBtn.addEventListener('click', exportMapPNG);

    const findBtn = document.getElementById('find-location');
    if (findBtn) findBtn.addEventListener('click', () => findMyLocation(findBtn));

    const zoomBtn = document.getElementById('zoom-extent');
    if (zoomBtn) zoomBtn.addEventListener('click', zoomToExtent);

    // Add top-left control with Zoom / Locate / Export buttons
    class MapTopLeftControl {
      onAdd(mapInstance) {
        this._map = mapInstance;
        this._container = document.createElement('div');
        this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group map-control-container';

        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.title = 'Zoom to extent';
        // fit/extent icon (corner brackets)
        btnZoom.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M3 3h8v2H5v6H3V3zm18 0v8h-2V5h-6V3h8zM3 21v-8h2v6h6v2H3zm18 0h-8v-2h6v-6h2v8z"/>
          </svg>`;
        btnZoom.className = 'ctrl-btn';
        // accessible label
        const zLabel = document.createElement('span');
        zLabel.className = 'visually-hidden';
        zLabel.textContent = 'Zoom to extent';
        btnZoom.appendChild(zLabel);
        btnZoom.addEventListener('click', () => zoomToExtent());

        const btnLocate = document.createElement('button');
        btnLocate.type = 'button';
        btnLocate.title = 'Find my location';
        // crosshair / locate icon
        btnLocate.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M11 2h2v3.07A7.001 7.001 0 0118.93 11H22v2h-3.07A7.001 7.001 0 0113 18.93V22h-2v-3.07A7.001 7.001 0 015.07 13H2v-2h3.07A7.001 7.001 0 0111 5.07V2zm1 7a4 4 0 100 8 4 4 0 000-8z"/>
          </svg>`;
        btnLocate.className = 'ctrl-btn';
        const lLabel = document.createElement('span');
        lLabel.className = 'visually-hidden';
        
        btnLocate.appendChild(lLabel);
        btnLocate.addEventListener('click', () => findMyLocation(btnLocate));

        const btnExport = document.createElement('button');
        btnExport.type = 'button';
        btnExport.title = 'Export map';
        // download arrow icon (downward arrow)
        btnExport.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M5 20h14v-2H5v2zm7-12l5 5h-3v4h-4v-4H7l5-5z"/>
          </svg>`;
        btnExport.className = 'ctrl-btn';
        const eLabel = document.createElement('span');
        eLabel.className = 'visually-hidden';
        eLabel.textContent = 'Export map';
        btnExport.appendChild(eLabel);

        // create export menu (PNG / JPEG / PDF)
        const exportMenu = document.createElement('div');
        exportMenu.className = 'export-menu';

        const btnPng = document.createElement('button');
        btnPng.type = 'button';
        btnPng.textContent = 'Download PNG';
        btnPng.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('png');
          exportMenu.classList.remove('show');
        });

        const btnJpeg = document.createElement('button');
        btnJpeg.type = 'button';
        btnJpeg.textContent = 'Download JPEG';
        btnJpeg.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('jpeg');
          exportMenu.classList.remove('show');
        });

        const btnPdf = document.createElement('button');
        btnPdf.type = 'button';
        btnPdf.textContent = 'Download PDF';
        btnPdf.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('pdf');
          exportMenu.classList.remove('show');
        });

        exportMenu.appendChild(btnPng);
        exportMenu.appendChild(btnJpeg);
        exportMenu.appendChild(btnPdf);

        // toggle menu on export button click
        btnExport.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        // close export menu when clicking outside
        document.addEventListener('click', (ev) => {
          if (!exportMenu.contains(ev.target) && ev.target !== btnExport) {
            exportMenu.classList.remove('show');
          }
        });

        // Tooltips accessible
        btnZoom.setAttribute('aria-label', 'Zoom to extent');
        btnLocate.setAttribute('aria-label', 'Find my location');
        btnExport.setAttribute('aria-label', 'Export map (PNG)');

        this._container.appendChild(btnZoom);
        this._container.appendChild(btnLocate);
  this._container.appendChild(btnExport);
  this._container.appendChild(exportMenu);

        return this._container;
      }
      onRemove() {
        this._container.parentNode.removeChild(this._container);
        this._map = undefined;
      }
    }

    // add the control to top-left
    map.addControl(new MapTopLeftControl(), 'top-left');

    // ------------------------- Minimizable Panels -------------------------
    // Panels are fixed to the right side; only minimize/restore is supported.
    (function enablePanels() {
      const panels = document.querySelectorAll('.draggable-panel');

      panels.forEach(panel => {
        const minBtn = panel.querySelector('.minimize-btn');

        // minimize / restore toggle
        if (minBtn) {
          minBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            panel.classList.toggle('collapsed');
            minBtn.textContent = panel.classList.contains('collapsed') ? '+' : '−';
          });
        }

        // allow clicking the small icon when collapsed to restore/expand
        const icon = panel.querySelector('.panel-icon');
        if (icon) {
          icon.style.cursor = 'pointer';
          icon.addEventListener('click', (e) => {
            e.stopPropagation();
            // if currently collapsed, restore; otherwise collapse
            const isCollapsed = panel.classList.contains('collapsed');
            panel.classList.toggle('collapsed');
            // update corresponding minimize button text if present
            if (minBtn) minBtn.textContent = panel.classList.contains('collapsed') ? '+' : '−';
          });
        }
      });
    })();





  </script>
  <!-- jsPDF for client-side PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- html2canvas for full-page screenshot export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <!-- main.js includes the layers and other map logic--> 
  <script src="main.js"></script>
</body>
</html>
