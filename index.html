<html>
<head>
  <meta charset="utf-8" />
  <title>Choropleth with MapLibre GL JS</title>
  <link
    href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="style.css"  />
  <style>
    body { margin: 0; padding: 0; }
    #map { width: 100%; height: 100vh; }
    .popup-table tr:nth-child(even) { background: #fce0b0; }
    /* Data sources logos inside side panel */
    #layer-panel .data-logos { display:flex; gap:8px; align-items:center; margin-top:6px; }
    #layer-panel .data-logos img { height:34px; width:auto; display:block; border-radius:4px; background:#fff; padding:4px; box-shadow:0 1px 2px rgba(0,0,0,0.08); }
    /* Top-left map control styling */
  .map-control-container{background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 6px 20px rgba(14,30,37,0.12);display:flex;flex-direction:column;gap:8px;position:relative}
    /* base button style */
    .map-control-container .ctrl-btn{background:#fff;border:1px solid rgba(16,24,32,0.08);padding:8px;border-radius:8px;cursor:pointer;font-size:14px;display:inline-flex;align-items:center;justify-content:center;min-width:40px;min-height:40px;box-shadow:0 1px 2px rgba(0,0,0,0.04);transition:all 180ms ease}
    .map-control-container .ctrl-btn:focus{outline:none;box-shadow:0 0 0 3px rgba(25,120,200,0.14)}
    .map-control-container .ctrl-btn:hover{background:#f4f8fb}
    /* icons inside the control buttons */
  .map-control-container .ctrl-btn svg { width: 18px; height: 18px; display: block; margin: 0 auto; fill: #263238; transition:fill 160ms ease }
  .map-control-container .ctrl-btn:hover svg { fill: #1978c8 }
  /* visually hidden text for screen readers */
  .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap;border:0;padding:0;margin:-1px}
  /* export menu */
  .export-menu{display:none;position:absolute;left:0;top:calc(100% + 8px);background:#fff;border:1px solid #eee;border-radius:8px;padding:6px;box-shadow:0 10px 30px rgba(14,30,37,0.12);min-width:150px;z-index:10}
  .export-menu.show{display:block}
  .export-menu button{display:flex;gap:8px;align-items:center;width:100%;text-align:left;padding:8px;border-radius:6px;border:none;background:transparent;cursor:pointer;font-size:14px}
  .export-menu button:hover{background:#f6f9fc}
    /* hide the panel buttons (we'll add controls on the map) */
    #layer-panel .panel-control-hidden{display:none}
</style>

</head>
<body>
  <div id="map"></div>
  <div id="layer-panel">
    <h3>Layers</h3>

    <!-- Base maps -->
    <div class="layer-group">
      <div class="layer-header">
        <span class="layer-title">Base Maps</span>
      </div>
      <div class="layer-sub">
        <label style="display:block; margin-bottom:6px;">
          <input type="radio" name="basemap" value="street" checked>
          Street
        </label>
        <label style="display:block;">
          <input type="radio" name="basemap" value="satellite">
          Satellite
        </label>
      </div>
    </div>

    <!-- Export / Controls (moved to map top-left) -->

    <!-- Regions -->
    <div class="layer-group">
      <div class="layer-header">
        <input type="checkbox" id="regions-visible" checked>
        <label for="regions-visible" class="layer-title">Regions</label>
      </div>

      <div class="layer-sub">
        <label class="sub-toggle">
          <input type="checkbox" id="regions-labels-visible" checked>
          Labels
        </label>

        <div class="opacity-row">
          <span>Opacity</span>
          <input type="range" id="regions-opacity" min="0" max="1" step="0.05" value="1">
        </div>
      </div>
    </div>

    <!-- Markers -->
    <div class="layer-group">
      <div class="layer-header">
        <span class="layer-title">Markers</span>
      </div>

      <div class="layer-sub">
        <label class="sub-toggle">
          <input type="checkbox" id="marker-default-visible" checked>
          Default Marker
        </label>

        <label class="sub-toggle">
          <input type="checkbox" id="marker-png-visible" checked>
          PNG Marker
        </label>

        <label class="sub-toggle">
          <input type="checkbox" id="marker-html-visible" checked>
          HTML Marker
        </label>
      </div>
    </div>
    
    <!-- Data sources / credits -->
    <div class="layer-group" style="margin-top:10px; font-size:13px;">
      <div class="layer-header">
        <span class="layer-title">Data sources</span>
      </div>
      <div class="layer-sub" style="padding:6px 4px; color:#333;">
        <!-- Logos: your files were detected in the local 'logo/' folder; update names here if needed -->
        <div class="data-logos">
          <img src="logo/logo_cde.jpg" alt="Copernicus Master in Digital Earth logo">
          <img src="logo/uni-sbg-logo.png" alt="Paris Lodron University Olomouc logo">
          <img src="logo/upol_logo.png" alt="Palacký University Olomouc logo">
        </div>
        <div class="data-credit" style="margin-top:8px; color:#333; font-size:13px;">
          Map tiles © <a href="https://www.openstreetmap.org/" target="_blank" rel="noopener">OpenStreetMap contributors</a>
          &nbsp;|&nbsp; Satellite © <a href="https://www.esri.com/en-us/home" target="_blank" rel="noopener">Esri</a>
          &nbsp;|&nbsp; Data: <a href="data/austria-demography-simplified-wgs84.geojson" target="_blank">Austria demography (GeoJSON)</a>
          &nbsp;|&nbsp; Icons: <code>marker.png</code>
        </div>
        <div style="margin-top:6px; color:#666; font-size:12px;">Please respect each provider's terms of use and attribution requirements.</div>
      </div>
    </div>
  </div>


  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
    //map initialization
    // Use a minimal/empty style so our raster OSM layer becomes the visible basemap
    const map = new maplibregl.Map({
      container: "map",
      style: {
        version: 8,
        sources: {},
        layers: []
      },
      center: [14.1, 47.75],
      zoom: 6.8
    });

    
    // ------------------------------------choropleth layer------------------------------------  //
    // Add GeoJSON source and layers    
    map.on("load", () => {
      map.addSource("regions", {
        type: "geojson",
        data: "data/austria-demography-simplified-wgs84.geojson"
      });

      // Add fill layer with data-driven color using expression
      map.addLayer({
        id: "regions-fill",
        type: "fill", 
        source: "regions",
        paint: {
          "fill-color": "#ffc7c7", /*[
            "interpolate",
            ["linear"],
            ["get", "POP_DENSIT"],    // property from  GeoJSON
            50, "#ffc7c7",
            100, "#ffadad",
            150, "#ff8f8f",
            200, "#ff5c5c",
            250, "#ff2e2e",
            4653, "#d50101",
          ],*/
          "fill-opacity": 0.8,
        },
      });

      // Add stroke
      map.addLayer({
        id: "regions-outline",
        type: "line",
        source: "regions",
        // simple paint for outline
        // paint: {
        //   "line-color": "#ffffff",
        //   "line-width": 1
        // }

        //complex paint for outline on hover effect
        paint: {
          //better to change fill color instead of line color on hover
          // "line-color": [
          //   "case",
          //   ["boolean", ["feature-state", "hover"], false],
          //   "#FF0000",  // red when hovered
          //   "#ffffff"   // normal
          // ],
          "line-color": "#ffffff",
          "line-width": [
            "case",
            ["boolean", ["feature-state", "hover"], false], 
            3,          // thick on hover
            1           // normal
          ]
        }
      });

      
      // Add labels on a layer
      map.addLayer({
        id: "regions-labels",
        type: "symbol",
        source: "regions",
        layout: {
          "text-field": ["get", "NAME"],      // your label property
          "text-size": 12,
          "symbol-placement": "point"
        },
        paint: {
          "text-color": "#000",
          "text-halo-color": "#fff",
          "text-halo-width": 1.5
        }
      });

      // --- Base map raster sources & layers (Street and Satellite) ---
      // Street (OpenStreetMap)
      map.addSource('basemap-street-source', {
        type: 'raster',
        // use explicit subdomain URLs (a, b, c) instead of a range placeholder
        tiles: [
          'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        attribution: '© OpenStreetMap contributors'
      });

      // Satellite (Esri World Imagery)
      map.addSource('basemap-satellite-source', {
        type: 'raster',
        tiles: [
          'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
        ],
        tileSize: 256,
        attribution: 'Tiles © Esri'
      });

      // Add street raster layer (visible by default) and place it beneath the regions
      map.addLayer({
        id: 'basemap-street',
        type: 'raster',
        source: 'basemap-street-source'
      }, 'regions-fill');

      // Add satellite raster layer (hidden by default)
      map.addLayer({
        id: 'basemap-satellite',
        type: 'raster',
        source: 'basemap-satellite-source',
        layout: { 'visibility': 'none' }
      }, 'regions-fill');

      // Wire up radio buttons to toggle the base layers
      const basemapRadios = document.querySelectorAll('input[name="basemap"]');
      basemapRadios.forEach(r => r.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'street') {
          map.setLayoutProperty('basemap-street', 'visibility', 'visible');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'none');
        } else if (val === 'satellite') {
          map.setLayoutProperty('basemap-street', 'visibility', 'none');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'visible');
        }
      }));

    }); 


    //------------------------------------markers------------------------------------  //
      //default marker start
      const markerDefault = new maplibregl.Marker()
        .setLngLat([16.3725, 48.2084]);

      markerDefault.addTo(map);
      //default marker end

      //custom marker png start
      const el = document.createElement("div");
      const img = document.createElement("img");
      img.src = "./marker.png";
      img.style.width = "25px";
      img.style.height = "40px";
      el.appendChild(img);

      const markerPNG  = new maplibregl.Marker({ element: el })
        .setLngLat([16.0725, 48.0084])
        .addTo(map);
      //custom marker png end


      //html marker start
      const el1 = document.createElement("div");
      el1.innerHTML = `
        <div style="
            background:#ff5722;
            color:white;
            padding:4px 8px;
            border-radius:6px;
            font-size:12px;
        ">HTML Marker</div>
      `;
      const markerHTML = new maplibregl.Marker({ element: el1 })
        .setLngLat([15.8725, 48.2084])
        .addTo(map);
      //html marker end

      // marker for user's location (set when Find my location is used)
      let locationMarker = null;

      
     // -------------------------------marker popups-----------------------------------------  // 
      // prevent polygon click when point marker is clicked
      markerPNG.getElement().addEventListener("click", (e) => {
        e.stopPropagation();       // prevents polygon popup
        markerPNG.togglePopup();      // shows marker popup
      });

      //marker popup simple way to set popup
      const popup = new maplibregl.Popup({ offset: 25 })
        .setHTML("<h3>Marker Info</h3><p>This is a PNG marker.</p>");

      // Attach popup to marker
      markerPNG.setPopup(popup);


      // Function to build popup HTML content
      function buildPopupHTML(properties) {
        const name = properties.NAME || properties.name || null;

        // Create table rows for all properties except NAME
        const rows = Object.entries(properties)
        .filter(([key]) => key.toLowerCase() !== "name")
        .map(
          ([key, value], i) => `
            <tr style="background:${i % 2 ? "#eddbdb" : "#ffffff"}">
              <td style="padding:4px 6px; color: #272727"><strong>${key}</strong></td>
              <td style="padding:4px 6px;">${value}</td>
            </tr>
          `
        )
        .join("");


        return `
          <div style="
            max-width: 260px;
            font-family: sans-serif;
          ">
            ${name ? `<h3 style="
                margin: 0 0 8px 0;
                font-size: 16px;
                font-weight: bold;
                border-bottom: 1px solid #ccc;
                padding: 7px;
                background: #eccaca;
                color: #272727;
            ">${name}</h3>` : ""}

            <div style="
              max-height: 150px;
              overflow-y: auto;
              border: 1px solid #ddd;
              border-radius: 4px;
            ">
              <table style="
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
              ">
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>
          </div>
        `;
    }

    // Add click event to show popup    
    map.on("click", "regions-fill", (e) => {
    const props = e.features[0].properties;

    new maplibregl.Popup({ closeButton: true })
        .setLngLat(e.lngLat)
        .setHTML(buildPopupHTML(props))
        .addTo(map);
    });


    //--------------------------------mouseover effect------------------------------------  //
    let hoveredFeatureId = null;

    map.on("mousemove", "regions-fill", (e) => {
      if (!e.features.length) return;

      const feature = e.features[0];
      if (hoveredFeatureId !== null && hoveredFeatureId !== feature.id) {
        map.setFeatureState(
          { source: "regions", id: hoveredFeatureId },
          { hover: false }
        );
      }

      hoveredFeatureId = feature.id;

      map.setFeatureState(
        { source: "regions", id: hoveredFeatureId },
        { hover: true }
      );
    });

    map.on("mouseleave", "regions-fill", () => {
      if (hoveredFeatureId !== null) {
        map.setFeatureState(
          { source: "regions", id: hoveredFeatureId },
          { hover: false }
        );
      }
      hoveredFeatureId = null;
    });



    //--------------------------------cursor pointer on layers during hover------------------------------------  //
    // Change cursor to pointer when hovering over interactive layers
    map.on("load", () => {
      map.on("mousemove", (e) => {
        const features = map.queryRenderedFeatures(e.point, {
          layers: ["regions-fill", "regions-outline", "regions-labels"]
        });

        if (features.length) {
          map.getCanvas().style.cursor = "pointer";
        } else {
          map.getCanvas().style.cursor = "";
        }
      });

    
      markerDefault.getElement().style.cursor = "pointer";
      markerPNG.getElement().style.cursor = "pointer";  
      markerHTML.getElement().style.cursor = "pointer";



      // Add scale control (like Google Maps)
      const scale = new maplibregl.ScaleControl({
        maxWidth: 140,
        unit: "metric" // use 'imperial' for miles, 'nautical' for nautical miles
      });
      map.addControl(scale, "bottom-left");
    });

    // Export / Locate / Zoom functions (used by map controls)
    function exportMapPNG() {
      // kept for backwards compatibility
      exportMap('png');
    }

    // Unified export function supporting png, jpeg and pdf
    async function exportMap(format = 'png') {
      try {
        const canvas = map.getCanvas();
        if (!canvas) throw new Error('Map canvas not available');

        if (format === 'pdf') {
          // convert canvas to dataURL and use jsPDF to create a PDF
          const dataUrl = canvas.toDataURL('image/png');
          // ensure jsPDF is loaded
          const jspdf = window.jspdf || window.jspdf === undefined ? window.jspdf : window.jspdf;
          const jsPDFClass = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jsPDF ? window.jsPDF : null);
          if (!jsPDFClass) {
            alert('PDF export requires jsPDF. Please check your internet connection.');
            return;
          }
          const img = new Image();
          img.src = dataUrl;
          img.onload = () => {
            // create pdf with orientation based on image aspect
            const imgW = img.width;
            const imgH = img.height;
            const imgRatio = imgW / imgH;
            const pdf = new jsPDFClass({ unit: 'pt', format: 'a4' });
            const pageW = pdf.internal.pageSize.getWidth();
            const pageH = pdf.internal.pageSize.getHeight();
            // fit image into page while preserving aspect ratio
            let renderW = pageW;
            let renderH = pageW / imgRatio;
            if (renderH > pageH) {
              renderH = pageH;
              renderW = pageH * imgRatio;
            }
            const marginX = (pageW - renderW) / 2;
            const marginY = (pageH - renderH) / 2;
            pdf.addImage(dataUrl, 'PNG', marginX, marginY, renderW, renderH);
            pdf.save('map.pdf');
          };
          img.onerror = (e) => {
            console.error('Image load error for PDF export', e);
            alert('PDF export failed (image load).');
          };
          return;
        }

        // for png and jpeg
        const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
        const quality = format === 'jpeg' ? 0.92 : undefined;

        if (canvas.toBlob) {
          canvas.toBlob((blob) => {
            if (!blob) {
              throw new Error('Failed to generate image blob');
            }
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`;
            document.body.appendChild(link);
            link.click();
            link.remove();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
          }, mime, quality);
        } else {
          const dataUrl = mime === 'image/png' ? canvas.toDataURL('image/png') : canvas.toDataURL('image/jpeg', quality);
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`;
          document.body.appendChild(link);
          link.click();
          link.remove();
        }
      } catch (err) {
        console.error('Export failed:', err);
        alert('Export failed. This usually happens when map tiles are loaded from servers that do not send CORS headers, which taints the canvas and prevents image export.\n\nPossible fixes:\n- Use a tile provider that supports CORS (with Access-Control-Allow-Origin).\n- Run a local tile proxy or self-host tiles.\n- Use a hosted map style that allows exporting.\n\nSee the console for the exact error.');
      }

    }

    // Create a Google-like location marker (SVG teardrop with white center)
    function createLocationMarkerElement() {
      const wrapper = document.createElement('div');
      wrapper.style.width = '36px';
      wrapper.style.height = '36px';
      wrapper.style.display = 'inline-block';
      wrapper.style.pointerEvents = 'none'; // let clicks pass through to map if needed

      // SVG teardrop marker: blue pin with white center and inner blue dot
      wrapper.innerHTML = `
        <svg width="36" height="36" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z" fill="#1978c8"/>
          <circle cx="12" cy="9" r="3" fill="#fff"/>
          <circle cx="12" cy="9" r="1.5" fill="#1978c8"/>
        </svg>
      `;
      return wrapper;
    }

    // Convert meters to pixels at given latitude & zoom for WebMercator / MapLibre
    function metersToPixelsAtZoom(meters, latitude, zoom) {
      const earthCircumference = 40075016.686; // meters
      const latRad = latitude * Math.PI / 180;
      // formula: metersPerPixel = earthCircumference * cos(lat) / 2^(zoom + 8)
      const metersPerPixel = earthCircumference * Math.cos(latRad) / Math.pow(2, zoom + 8);
      return meters / metersPerPixel;
    }

    async function findMyLocation(triggerButton) {
      if (!('geolocation' in navigator)) {
        alert('Geolocation is not available in this browser.');
        return;
      }

      const btn = triggerButton || null;
      if (btn) {
        btn.disabled = true;
        var originalText = btn.textContent;
        btn.textContent = 'Locating...';
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lng = pos.coords.longitude;
          const lat = pos.coords.latitude;
          const accuracy = pos.coords.accuracy || 0; // meters

          map.flyTo({ center: [lng, lat], zoom: 14, speed: 1.2 });

          // Create or update the SVG marker
          if (locationMarker) {
            locationMarker.setLngLat([lng, lat]);
          } else {
            const el = createLocationMarkerElement();
            locationMarker = new maplibregl.Marker({ element: el, anchor: 'bottom' })
              .setLngLat([lng, lat])
              .addTo(map);
          }

          // Add / update an accuracy circle as a GeoJSON source + circle layer
          const accuracySourceId = 'location-accuracy-src';
          const accuracyLayerId = 'location-accuracy-layer';
          const pointGeoJSON = {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [lng, lat] },
            properties: { accuracy: accuracy }
          };

          if (!map.getSource(accuracySourceId)) {
            map.addSource(accuracySourceId, { type: 'geojson', data: pointGeoJSON });
            map.addLayer({
              id: accuracyLayerId,
              type: 'circle',
              source: accuracySourceId,
              paint: {
                'circle-color': '#1978c8',
                'circle-opacity': 0.12,
                'circle-stroke-color': '#1978c8',
                'circle-stroke-width': 1
              }
            }, 'regions-fill');
          } else {
            map.getSource(accuracySourceId).setData(pointGeoJSON);
          }

          // compute and set radius in pixels for the current zoom
          const pix = metersToPixelsAtZoom(accuracy, lat, map.getZoom());
          if (map.getLayer(accuracyLayerId)) {
            map.setPaintProperty(accuracyLayerId, 'circle-radius', pix);
          }

          // store latest accuracy data for zoom handler
          window._locationAccuracy = { lat, accuracy };

          // ensure we update the pixel radius on zoom changes (one-time hookup)
          if (!map._locationAccuracyHandler) {
            map._locationAccuracyHandler = function () {
              const a = window._locationAccuracy;
              if (!a) return;
              const newPix = metersToPixelsAtZoom(a.accuracy, a.lat, map.getZoom());
              if (map.getLayer(accuracyLayerId)) {
                map.setPaintProperty(accuracyLayerId, 'circle-radius', newPix);
              }
            };
            map.on('zoom', map._locationAccuracyHandler);
          }

          if (btn) {
            btn.disabled = false;
            btn.textContent = originalText;
          }
        },
        (err) => {
          console.error('Geolocation error:', err);
          alert('Unable to retrieve your location: ' + (err.message || err.code));
          if (btn) {
            btn.disabled = false;
            btn.textContent = originalText;
          }
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    async function zoomToExtent() {
      try {
        const url = 'data/austria-demography-simplified-wgs84.geojson';
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('Failed to fetch GeoJSON: ' + resp.status);
        const geojson = await resp.json();

        function updateBBoxFromCoords(coords, bbox) {
          if (typeof coords[0] === 'number' && coords.length >= 2) {
            const lng = coords[0];
            const lat = coords[1];
            if (lng < bbox[0]) bbox[0] = lng;
            if (lat < bbox[1]) bbox[1] = lat;
            if (lng > bbox[2]) bbox[2] = lng;
            if (lat > bbox[3]) bbox[3] = lat;
          } else if (Array.isArray(coords)) {
            coords.forEach(c => updateBBoxFromCoords(c, bbox));
          }
        }

        function bboxOfGeoJSON(gj) {
          const bbox = [Infinity, Infinity, -Infinity, -Infinity];
          if (gj.type === 'FeatureCollection') {
            gj.features.forEach(f => {
              if (f.geometry) updateBBoxFromCoords(f.geometry.coordinates, bbox);
            });
          } else if (gj.type === 'Feature' && gj.geometry) {
            updateBBoxFromCoords(gj.geometry.coordinates, bbox);
          } else if (gj.type === 'GeometryCollection' && gj.geometries) {
            gj.geometries.forEach(g => updateBBoxFromCoords(g.coordinates, bbox));
          } else if (gj.coordinates) {
            updateBBoxFromCoords(gj.coordinates, bbox);
          }
          if (bbox[0] === Infinity) return null;
          return [[bbox[0], bbox[1]], [bbox[2], bbox[3]]];
        }

        const bounds = bboxOfGeoJSON(geojson);
        if (!bounds) {
          alert('Could not compute bounds for the GeoJSON.');
          return;
        }

        map.fitBounds(bounds, { padding: 20, maxZoom: 14, duration: 800 });
      } catch (err) {
        console.error('Zoom to extent failed:', err);
        alert('Zoom to extent failed. Check the console for details.');
      }
    }

    // attach to any existing panel buttons if present (we removed panel buttons by default)
    const exportBtn = document.getElementById('export-map');
    if (exportBtn) exportBtn.addEventListener('click', exportMapPNG);

    const findBtn = document.getElementById('find-location');
    if (findBtn) findBtn.addEventListener('click', () => findMyLocation(findBtn));

    const zoomBtn = document.getElementById('zoom-extent');
    if (zoomBtn) zoomBtn.addEventListener('click', zoomToExtent);

    // Add top-left control with Zoom / Locate / Export buttons
    class MapTopLeftControl {
      onAdd(mapInstance) {
        this._map = mapInstance;
        this._container = document.createElement('div');
        this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group map-control-container';

        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.title = 'Zoom to extent';
        // fit/extent icon (corner brackets)
        btnZoom.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M3 3h8v2H5v6H3V3zm18 0v8h-2V5h-6V3h8zM3 21v-8h2v6h6v2H3zm18 0h-8v-2h6v-6h2v8z"/>
          </svg>`;
        btnZoom.className = 'ctrl-btn';
        // accessible label
        const zLabel = document.createElement('span');
        zLabel.className = 'visually-hidden';
        zLabel.textContent = 'Zoom to extent';
        btnZoom.appendChild(zLabel);
        btnZoom.addEventListener('click', () => zoomToExtent());

        const btnLocate = document.createElement('button');
        btnLocate.type = 'button';
        btnLocate.title = 'Find my location';
        // crosshair / locate icon
        btnLocate.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M11 2h2v3.07A7.001 7.001 0 0118.93 11H22v2h-3.07A7.001 7.001 0 0113 18.93V22h-2v-3.07A7.001 7.001 0 015.07 13H2v-2h3.07A7.001 7.001 0 0111 5.07V2zm1 7a4 4 0 100 8 4 4 0 000-8z"/>
          </svg>`;
        btnLocate.className = 'ctrl-btn';
        const lLabel = document.createElement('span');
        lLabel.className = 'visually-hidden';
        lLabel.textContent = 'Find my location';
        btnLocate.appendChild(lLabel);
        btnLocate.addEventListener('click', () => findMyLocation(btnLocate));

        const btnExport = document.createElement('button');
        btnExport.type = 'button';
        btnExport.title = 'Export map';
        // download arrow icon (downward arrow)
        btnExport.innerHTML = `
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M5 20h14v-2H5v2zm7-12l5 5h-3v4h-4v-4H7l5-5z"/>
          </svg>`;
        btnExport.className = 'ctrl-btn';
        const eLabel = document.createElement('span');
        eLabel.className = 'visually-hidden';
        eLabel.textContent = 'Export map';
        btnExport.appendChild(eLabel);

        // create export menu (PNG / JPEG / PDF)
        const exportMenu = document.createElement('div');
        exportMenu.className = 'export-menu';

        const btnPng = document.createElement('button');
        btnPng.type = 'button';
        btnPng.textContent = 'Download PNG';
        btnPng.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('png');
          exportMenu.classList.remove('show');
        });

        const btnJpeg = document.createElement('button');
        btnJpeg.type = 'button';
        btnJpeg.textContent = 'Download JPEG';
        btnJpeg.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('jpeg');
          exportMenu.classList.remove('show');
        });

        const btnPdf = document.createElement('button');
        btnPdf.type = 'button';
        btnPdf.textContent = 'Download PDF';
        btnPdf.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('pdf');
          exportMenu.classList.remove('show');
        });

        exportMenu.appendChild(btnPng);
        exportMenu.appendChild(btnJpeg);
        exportMenu.appendChild(btnPdf);

        // toggle menu on export button click
        btnExport.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        // close export menu when clicking outside
        document.addEventListener('click', (ev) => {
          if (!exportMenu.contains(ev.target) && ev.target !== btnExport) {
            exportMenu.classList.remove('show');
          }
        });

        // Tooltips accessible
        btnZoom.setAttribute('aria-label', 'Zoom to extent');
        btnLocate.setAttribute('aria-label', 'Find my location');
        btnExport.setAttribute('aria-label', 'Export map (PNG)');

        this._container.appendChild(btnZoom);
        this._container.appendChild(btnLocate);
  this._container.appendChild(btnExport);
  this._container.appendChild(exportMenu);

        return this._container;
      }
      onRemove() {
        this._container.parentNode.removeChild(this._container);
        this._map = undefined;
      }
    }

    // add the control to top-left
    map.addControl(new MapTopLeftControl(), 'top-left');





  </script>
  <!-- jsPDF for client-side PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- main.js includes the layers and other map logic--> 
  <script src="main.js"></script>
</body>
</html>
